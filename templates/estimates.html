{% set tab = 'estimates' %}
{% set container_class = 'container-fluid' %}

{% extends 'base.html' %}

{% block extra_js %}
    
    <script type="text/javascript">
    
      let pollingRateSeconds = 10;
      
      var app = new Vue({
        el: '#abr',
        delimiters: ['{$', '$}'],
        data: {
          isLoading: true,
          headers: ['Date', 'Due Date', 'Customer','Bike', 'Tag #', 'Estimate #', 'Total Labor Cost', 'Status'],
          estimates: [],
          error: {
            auth: false,
            unknown: false,
          },
          max_length_note: 250,
          isRequestingData: false,
          showingEstimateNotes: null,
        },
        methods: {
          estimate_has_tag_number: function(e) {
            return _.find(e['CustomField'], (field) => {
              return field['Name'] == 'Tag #' && field['StringValue'];
            });
          },
          get_estimates: function() {
            if (this.isRequestingData) {
              console.log('already fetching data...');
              return;
            }
            
            this.isRequestingData = true;
            
            // reset errors
            this.error = {
              auth: false,
              unknown: false,
            }; 
            
            this.$http.get('/json/estimates', {headers: {'content-type': 'application/json'}}).then((response) => {
              this.isRequestingData = false;
              
              response.json().then((json) => {
                
                this.isLoading = false;
                
                if (json['success']) {
                  if (json['estimates']) {
                    
                    // wipe and rebuild
                    this.estimates = [];
                    
                    // attempt to create a "due date+time" using the ExpirationDate and a custom time field
                    _.forEach(json.estimates, (estimate) => {
                       let due_time = moment(this.get_custom_field(estimate, 'Expiration Time'), 'h:mma');
                       if (due_time.isValid()) {
                         estimate.ExpirationDate = moment(estimate.ExpirationDate).hour(due_time.hours()).minute(due_time.minutes()).format();
                       }
                    })
                    
                    // group by statuses
                    let statusGroups = _.groupBy(json.estimates, 'TxnStatus');
                    
                    // sort estimates by due date
                    _.forEach(statusGroups, (group) => {
                     group.sort((a, b) => {
                       return new Date(a.ExpirationDate) - new Date(b.ExpirationDate);
                     });
                    });
                    
                    // distinguish in-shop vs not-in-shop "Pending" estimates
                    statusGroups['Pending-In'] = [];
                    statusGroups['Pending-Out'] = [];
                    _.each(statusGroups['Pending'], (estimate) => {
                      let group = this.estimate_has_tag_number(estimate) ? 'Pending-In' : 'Pending-Out';
                      statusGroups[group].push(estimate);    
                    });
                    // remove since we're splitting it out into two groups
                    delete statusGroups['Pending'];
                    
                    // build by status order preference
                    _.forEach(['Accepted', 'Pending-In', 'Pending-Out', 'Closed'], (status) => {
                      if (_.has(statusGroups, status)) {
                        _.forEach(statusGroups[status], (estimate) => {
                          estimate.class = status;
                          this.estimates.push(estimate);
                        });
                      }
                    });
                  }
                } else {
                  // authentication error
                  if (json['reason'] == 'authentication') {
                    this.error.auth = true; 
                  } else {
                    this.error.unknown = true; 
                  }
                  console.log('json failure', json, this.error);
                }
              });
            },
            // failure
            (error) => {
              this.isRequestingData = false;
              
              this.error.unknown = true; 
              console.log('failure', error);
            });
          },
          estimate_url: function (estimate) {
           return 'https://qbo.intuit.com/app/estimate?txnId=' + estimate.Id;
          },
          customer_url: function (estimate) {
            return 'https://qbo.intuit.com/app/customerdetail?nameId=' + estimate.CustomerRef.value;
          },
          get_custom_field: function (estimate, field) {
            let value = '';
            if(estimate['CustomField'] && estimate['CustomField'].length) {
              value = _.find(estimate['CustomField'], (f) => {
               return f['Name'] == field;
              });
            } 
            return value['StringValue'];
          },
          total_labor: function (estimate) {
            let total = 0;
            _.forEach(estimate['Line'], (item) => {
              // no tax indicates labor
              if (item['SalesItemLineDetail'] && item['SalesItemLineDetail']['TaxCodeRef'] && item['SalesItemLineDetail']['TaxCodeRef']['value'] === 'NON') {
                total += (item['SalesItemLineDetail']['UnitPrice'] * item['SalesItemLineDetail']['Qty']);
              } 
            }); 
            return total;
          },
          has_error: function () {
            return _.find(this.error, (type) => {
              return type ? true : false;
            });
          },
          show_estimate_notes: function(e) {
            this.showingEstimateNotes = e;
          },
          should_show_estimate_notes: function(e) {
            return this.showingEstimateNotes && this.showingEstimateNotes.Id == e.Id;
          },
          get_notes: function(e) {
            // show full notes
            if (this.should_show_estimate_notes(e)) {
              return e.PrivateNote;
            }
            // truncated notes
            else if (e.PrivateNote && e.PrivateNote.length >= this.max_length_note) {
              return e.PrivateNote.slice(0, this.max_length_note - 1) + '...';
            }
            return e.PrivateNote;
          },
          moment: moment,
        },
      });
      
      // load initial estimate data
      app.get_estimates();
      
      // frequently refresh estimate data
      setInterval(() => {
        app.get_estimates();
      }, pollingRateSeconds * 1000);
      
    </script>
{% endblock %}

{% block container %}
    
  <style>
    #abr table {
      width: 100%;
      font-size: 10px;
    }
    #abr table td {
      min-height: 40px;
    }
    th.Status {
      width: 50%;
    }
    tr.Accepted {
      background-color: #54fb59;  /* green */  
    }
    tr.Pending-In {
      background-color: #f1f150;  /* yellow */
    }
    tr.Pending-Out {
      background-color: rgba(255, 0, 0, 0.55);      /* red */
    }
    tr.Closed {
      background-color: #8383e0;  /* blue */
    }
    tr a {
      color: black;
    }
    
  </style>
  <div id="abr">
    
    <div v-if="isLoading"><img src="static/loading.svg"></div>
  
    <div v-if="!isLoading">
      
      <div class="alert alert-danger" v-if="has_error()">
        <p v-if="error.auth">Your session has expired. <a href="/">Please log in again</a></p>
        <p v-if="error.unknown">An Unknown Error Occurred</p>
      </div>
    
      <div class="table-responsive">
        <table class="table table-hover table-border table-condensed">
          <thead>
            <th v-for="header in headers" :class="header">{$ header $}</th>
          </thead>
          <tbody>
            <tr v-for="estimate in estimates" :class="estimate.class" v-on:click="show_estimate_notes(estimate)">
              <td>{$ moment(estimate.TxnDate).format('MM/DD/YY') $}</td>
              <td>{$ estimate.ExpirationDate ? moment(estimate.ExpirationDate).format('MM/DD/YY h:mma') : '' $}</td>
              <td><a v-bind:href="customer_url(estimate)" target="qbo">{$ estimate.CustomerRef.name $}</a></td>
              <td>{$ get_custom_field(estimate, 'Bike/Model') $}</td>
              <td>{$ get_custom_field(estimate, 'Tag #') $}</td>
              <td><a v-bind:href="estimate_url(estimate)" target="qbo">{$ estimate.DocNumber $}</a></td>
              <td>${$ total_labor(estimate) $}</td>
              <td>{$ get_notes(estimate) $}</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>
{% endblock %}

{% block head_js %}
{% endblock %}